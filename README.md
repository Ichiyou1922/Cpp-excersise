# Cpp-excersise
Cppの練習用リポジトリ

## 入出力ライブラリ
- `<iostream>`，`std::cout`など
- C++のI/Oは「ストリーム」と「演算子オーバーロード」を使う設計

## 名前空間（重要）
- 例えば`std::cout`の`std`は名前空間
- `std`という名前空間を指定し，その中の機能を使う
- `std::cout`，`name::cout`のようにして区別できる
- 標準ライブラリとグローバルな名前空間を切り分けられる

## コンパイラ
- `.cpp`を`g++`あるいは`clang++`でコンパイルする
```bash
g++ -std=c++17 main.cpp -o main
```

## CのI/OとC++のI/Oの違い
- C: `prinft`は文字列加工から出力までをまとめて抱えている．
  - 型不一致を検出できない，文字列の構造が複雑，拡張性低という課題
- C++: `std::cout`は出力ストリームというオブジェクト
  - I/Oを「データをストリーム(抽象化された出力装置)へ流す」という設計
  - `<<`はストリームへデータを送り込むための**演算子オーバーロード**
  - 出力形式は型に応じて**自動で**決定される
  - ユーザー定義クラスに対して`operator<<`を指定すれば，同じ文法で出力可能

## 参照型（重要）
- 参照とは「別名（alias）」->ポインタとは異なり「存在上の不変性」を持つ
  - 参照は初期化時に実態を束縛すること
  - 一度束縛されたら他の対象を指すように変更できないこと
    - ポインタと違って差し替え不可能
    - `int& r = a; r=b`としてもaの値がbの値で上書きされるだけ->rはbを参照しない
  - `nullptr`を参照には出来ない（実態を必ず持つから）
- 参照渡し
- Cでのポインタ渡し
```C
void f(int* x);
int a = 10;
f(&a);   // 10が入ったアドレスを渡していてわかりにくい
```
- C++での参照渡し
```Cpp
void f(int& x);
int a = 10;
f(a);   // 値渡しと同じ構文->aそのものを更新しますよと明示的
```
- C++の参照は値の入った金庫そのものを渡すようなもの
- C言語だと金庫(値が入っているかもわからない)の住所を渡していた

## クラス
- クラスは「メンバ変数」と「メンバ関数」の結合体
```cpp
class Particle {
private: 
    // 【非公開領域】
    // 外部から直接 particle.x = 10; のように触らせない．
    // 物理法則（メソッド）を通さない不正な書き換えを防ぐ．
    double x; // 位置
    double v; // 速度
    double m; // 質量

public: 
    // 【公開領域】
    // 外部とのインターフェース．

    // コンストラクタ（初期化）
    // 生成時に一度だけ呼ばれる．
    Particle(double initial_x, double initial_v, double mass) {
        x = initial_x; // これ以降xやvやmに触らせない．
        v = initial_v;
        m = mass;
    }

    // 状態更新メソッド（時間を dt 進める）
    // 自分のメンバ変数（x, v）を書き換えるので参照渡しは不要．
    // クラス内では x, v はグローバル変数の如く見える．
    void update(double a, double dt) {
        v = v + a * dt;      // 速度更新
        x = x + v * dt;      // 位置更新（オイラー法）
    }

    // 現在位置を取得するメソッド
    // const修飾: 「この関数はメンバ変数を書き換えない」という誓約
    double get_position() const {
        return x;
    }
};
```
```

- main関数でいくつもParticle型を作れる．
```cpp
int main() {
    // インスタンス化（コンストラクタが呼ばれる）
    Particle p1(0.0, 10.0, 2.0); 

    // メソッド呼び出し（ドット演算子）
    // 「p1 よ，加速度 9.8 で 0.1秒後の状態へ遷移せよ」という命令
    p1.update(-9.8, 0.1);

    std::cout << p1.get_position() << std::endl;
    return 0;
}
```
```
```

- 初期化子リスト
```
```cpp
    Particle(double initial_x, double initial_v, double mass) x(initial_x), v(initial_v), mass(initial_mass){
```
```
- この様な感じで，書く．
- 普通の代入と違うところは，「はじめから値を持つ箱を製造する」というところ．
- 変数生成時に値をもたせるのはC++の決まりというか思想というか．


